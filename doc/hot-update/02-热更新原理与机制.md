# 热更新原理与机制

## 目录

1. [React Native 热更新基础原理](#1-react-native-热更新基础原理)
2. [热更新的工作流程](#2-热更新的工作流程)
3. [版本管理机制](#3-版本管理机制)
4. [更新策略分级](#4-更新策略分级)
5. [安全机制](#5-安全机制)

---

## 1. React Native 热更新基础原理

### 1.1 React Native 应用的组成

React Native 应用由两部分组成：

```
┌─────────────────────────────────────┐
│     React Native 应用结构           │
├─────────────────────────────────────┤
│                                     │
│  ┌───────────────────────────────┐ │
│  │   原生代码 (Native Code)      │ │
│  │  - Java/Kotlin (Android)      │ │
│  │  - TurboModule               │ │
│  │  - 原生 UI 组件               │ │
│  │  - 需要重新安装 APK 才能更新  │ │
│  └───────────────────────────────┘ │
│                                     │
│  ┌───────────────────────────────┐ │
│  │   JS Bundle (JavaScript)      │ │
│  │  - 业务逻辑                   │ │
│  │  - UI 组件                    │ │
│  │  - Redux Store               │ │
│  │  - 可以热更新 ✅              │ │
│  └───────────────────────────────┘ │
│                                     │
└─────────────────────────────────────┘
```

### 1.2 热更新的核心原理

**关键点**：React Native 在运行时动态加载 JS Bundle 文件。

```kotlin
// React Native 加载 JS Bundle 的过程
ReactInstanceManager.builder()
    .setBundleAssetName("index.android.bundle")  // 从 assets 加载
    // 或
    .setJSBundleFile("/data/data/com.app/files/bundle.js")  // 从文件系统加载
    .build()
```

**热更新原理**：
1. 应用启动时，检查是否有新的 JS Bundle
2. 如果有，从本地文件系统加载新 Bundle
3. 如果没有，从 APK 的 assets 目录加载默认 Bundle
4. 通过 `ReactInstanceManager.recreateReactContextInBackground()` 重新加载

### 1.3 为什么可以热更新？

```
传统 APK 更新：
┌──────────┐    ┌──────────┐    ┌──────────┐
│ 修改代码 │ -> │ 打包 APK │ -> │ 安装 APK │
└──────────┘    └──────────┘    └──────────┘
   耗时长         需要签名        需要用户操作

热更新：
┌──────────┐    ┌──────────┐    ┌──────────┐
│ 修改 JS  │ -> │ 打包 Bundle│ -> │ 下载替换 │
└──────────┘    └──────────┘    └──────────┘
   快速           几兆大小        自动完成
```

---

## 2. 热更新的工作流程

### 2.1 完整流程图

```
┌─────────────────────────────────────────────────────────────┐
│                    热更新完整流程                            │
└─────────────────────────────────────────────────────────────┘

服务端                          客户端
  │                              │
  │  1. 发布新版本               │
  ├──────────────────────────────>│
  │     WebSocket 推送通知        │
  │                              │
  │                              │  2. 检查更新
  │<─────────────────────────────┤
  │     请求版本信息              │
  │                              │
  │  3. 返回版本信息             │
  ├──────────────────────────────>│
  │     (版本号、下载地址、策略)  │
  │                              │
  │                              │  4. 判断是否需要更新
  │                              │     - 比对版本号
  │                              │     - 检查灰度规则
  │                              │
  │                              │  5. 下载更新包
  │<─────────────────────────────┤
  │     下载 Bundle 文件          │
  │                              │
  │  6. 返回 Bundle 文件         │
  ├──────────────────────────────>│
  │                              │
  │                              │  7. 校验更新包
  │                              │     - 签名验证
  │                              │     - 完整性校验
  │                              │
  │                              │  8. 备份当前版本
  │                              │
  │                              │  9. 安装新版本
  │                              │     - 解压到指定目录
  │                              │     - 更新版本信息
  │                              │
  │                              │  10. 重启应用
  │                              │      - 调用 restartApplication()
  │                              │      - 加载新 Bundle
  │                              │
  │                              │  11. 启动超时检测
  │                              │      - 30秒倒计时
  │                              │
  │                              │  12. 初始化完成
  │                              │      - notifyScreenInitialized()
  │                              │      - 取消超时检测
  │                              │
  │  13. 上报更新结果            │
  │<─────────────────────────────┤
  │     成功/失败统计             │
  │                              │
```

### 2.2 关键步骤详解

#### 步骤 1-3：版本检查

```typescript
// 客户端请求版本信息
interface CheckUpdateRequest {
  deviceId: string;        // 设备 ID
  storeId: string;         // 门店 ID
  currentVersion: string;  // 当前 JS Bundle 版本
  nativeVersion: string;   // 原生版本号
  platform: 'android';
}

// 服务端返回版本信息
interface CheckUpdateResponse {
  hasUpdate: boolean;      // 是否有更新
  version: string;         // 新版本号
  downloadUrl: string;     // 下载地址
  fileSize: number;        // 文件大小（字节）
  md5: string;            // MD5 校验值
  signature: string;       // RSA 签名
  updateStrategy: 'force' | 'auto' | 'prompt';  // 更新策略
  description: string;     // 更新说明
  minNativeVersion: string; // 最低原生版本要求
}
```

#### 步骤 4：判断是否需要更新

```kotlin
fun shouldUpdate(response: CheckUpdateResponse): Boolean {
    // 1. 检查原生版本是否满足要求
    if (!isNativeVersionCompatible(response.minNativeVersion)) {
        return false
    }

    // 2. 比对版本号
    if (response.version <= currentVersion) {
        return false
    }

    // 3. 检查灰度规则（服务端已过滤）
    return response.hasUpdate
}
```

#### 步骤 7：校验更新包

```kotlin
fun verifyBundle(file: File, md5: String, signature: String): Boolean {
    // 1. MD5 完整性校验
    val fileMd5 = calculateMD5(file)
    if (fileMd5 != md5) {
        Log.e(TAG, "MD5 校验失败")
        return false
    }

    // 2. RSA 签名验证
    if (!verifySignature(file, signature)) {
        Log.e(TAG, "签名验证失败")
        return false
    }

    return true
}
```

#### 步骤 11-12：超时检测与回滚

```kotlin
// 启动超时检测
fun startTimeoutDetection() {
    timeoutHandler.postDelayed({
        if (!isInitialized) {
            Log.e(TAG, "初始化超时，回滚到上一版本")
            rollbackToPreviousVersion()
            restartApplication()
        }
    }, 30000) // 30秒超时
}

// 初始化完成，取消超时检测
fun onScreenInitialized() {
    isInitialized = true
    timeoutHandler.removeCallbacksAndMessages(null)
    reportUpdateSuccess()
}
```

---

## 3. 版本管理机制

### 3.1 版本号规范

采用**双版本号**管理策略：

```
原生版本号（Native Version）
格式：主版本.次版本.修订版本
示例：1.2.3
用途：APK 版本，需要重新安装才能更新

JS Bundle 版本号（Bundle Version）
格式：主版本.次版本.修订版本.构建号
示例：1.2.3.456
用途：热更新版本，可动态更新
```

### 3.2 版本兼容性

```
┌─────────────────────────────────────┐
│      版本兼容性矩阵                  │
├─────────────────────────────────────┤
│                                     │
│  原生版本 1.0.0                     │
│    ├─ Bundle 1.0.0.1 ✅            │
│    ├─ Bundle 1.0.0.2 ✅            │
│    └─ Bundle 1.0.1.1 ❌ (不兼容)   │
│                                     │
│  原生版本 1.1.0                     │
│    ├─ Bundle 1.1.0.1 ✅            │
│    ├─ Bundle 1.1.0.2 ✅            │
│    └─ Bundle 1.0.0.1 ❌ (不兼容)   │
│                                     │
└─────────────────────────────────────┘

规则：
1. Bundle 的主版本和次版本必须与原生版本一致
2. 只有修订版本和构建号可以热更新
3. 如果需要更新主版本或次版本，必须更新 APK
```

### 3.3 版本存储结构

```
/data/data/com.impos2desktopv1/files/
├── bundles/
│   ├── current/                    # 当前使用的版本
│   │   ├── index.android.bundle
│   │   ├── assets/
│   │   └── version.json
│   │
│   ├── backup/                     # 备份版本（用于回滚）
│   │   ├── index.android.bundle
│   │   ├── assets/
│   │   └── version.json
│   │
│   └── history/                    # 历史版本（保留10个）
│       ├── 1.0.0.450/
│       ├── 1.0.0.451/
│       ├── ...
│       └── 1.0.0.459/
│
└── update/
    ├── download/                   # 下载临时目录
    │   └── bundle.zip
    └── metadata.json               # 更新元数据
```


### 3.4 版本信息文件

```json
// version.json
{
  "bundleVersion": "1.0.0.456",
  "nativeVersion": "1.0.0",
  "buildTime": "2026-02-05T10:30:00Z",
  "md5": "a1b2c3d4e5f6...",
  "signature": "RSA签名字符串",
  "description": "修复登录模块bug"
}
```

---

## 4. 更新策略分级

### 4.1 三级更新策略

```
┌─────────────────────────────────────────────────────────────┐
│                    更新策略分级                              │
└─────────────────────────────────────────────────────────────┘

1. 强制静默更新 (force)
   ├─ 触发条件：严重 bug、安全漏洞
   ├─ 用户体验：无提示，后台下载，自动重启
   ├─ 适用场景：紧急修复
   └─ 实现方式：下载完成后立即重启

2. 自动静默更新 (auto)
   ├─ 触发条件：功能优化、小 bug 修复
   ├─ 用户体验：后台下载，下次启动时生效
   ├─ 适用场景：日常更新
   └─ 实现方式：下载完成后等待下次启动

3. 提示更新 (prompt)
   ├─ 触发条件：新功能发布
   ├─ 用户体验：弹窗提示，用户选择是否更新
   ├─ 适用场景：重大功能更新
   └─ 实现方式：显示更新对话框
```

### 4.2 策略决策流程

```kotlin
fun determineUpdateStrategy(
    updateInfo: UpdateInfo,
    currentVersion: String
): UpdateStrategy {
    // 1. 检查是否为强制更新
    if (updateInfo.isForceUpdate) {
        return UpdateStrategy.FORCE
    }

    // 2. 检查版本差异
    val versionDiff = compareVersion(updateInfo.version, currentVersion)
    
    // 3. 根据版本差异决定策略
    return when {
        versionDiff.major > 0 -> UpdateStrategy.PROMPT  // 主版本变化
        versionDiff.minor > 0 -> UpdateStrategy.AUTO    // 次版本变化
        else -> UpdateStrategy.AUTO                      // 修订版本变化
    }
}
```

### 4.3 用户交互设计

#### 强制静默更新
```
无 UI 提示
后台下载 → 自动重启 → 加载新版本
```

#### 自动静默更新
```
状态栏通知（可选）
后台下载 → 等待下次启动 → 加载新版本
```

#### 提示更新
```
┌─────────────────────────────────┐
│      发现新版本 v1.0.0.456      │
├─────────────────────────────────┤
│                                 │
│  更新内容：                     │
│  - 优化登录流程                 │
│  - 修复支付模块bug              │
│  - 提升性能                     │
│                                 │
│  大小：3.2 MB                   │
│                                 │
│  ┌──────────┐  ┌──────────┐   │
│  │  稍后更新  │  │  立即更新  │   │
│  └──────────┘  └──────────┘   │
└─────────────────────────────────┘
```

---

## 5. 安全机制

### 5.1 安全威胁分析

```
潜在威胁：
1. 中间人攻击（MITM）
   └─ 攻击者篡改下载的 Bundle 文件

2. 恶意 Bundle 注入
   └─ 攻击者替换服务器上的 Bundle

3. 降级攻击
   └─ 攻击者强制设备使用旧版本

4. 重放攻击
   └─ 攻击者重复发送旧的更新请求
```

### 5.2 安全防护措施

#### 5.2.1 HTTPS 传输加密

```
客户端 <--HTTPS--> 服务器
         TLS 1.3
         证书验证
```

#### 5.2.2 RSA 签名验证

```kotlin
// 服务端：使用私钥签名
fun signBundle(bundleFile: File, privateKey: PrivateKey): String {
    val signature = Signature.getInstance("SHA256withRSA")
    signature.initSign(privateKey)
    signature.update(bundleFile.readBytes())
    return Base64.encodeToString(signature.sign(), Base64.NO_WRAP)
}

// 客户端：使用公钥验证
fun verifySignature(
    bundleFile: File,
    signatureStr: String,
    publicKey: PublicKey
): Boolean {
    val signature = Signature.getInstance("SHA256withRSA")
    signature.initVerify(publicKey)
    signature.update(bundleFile.readBytes())
    val signatureBytes = Base64.decode(signatureStr, Base64.NO_WRAP)
    return signature.verify(signatureBytes)
}
```

#### 5.2.3 MD5 完整性校验

```kotlin
fun calculateMD5(file: File): String {
    val md = MessageDigest.getInstance("MD5")
    file.inputStream().use { input ->
        val buffer = ByteArray(8192)
        var read: Int
        while (input.read(buffer).also { read = it } > 0) {
            md.update(buffer, 0, read)
        }
    }
    return md.digest().joinToString("") { "%02x".format(it) }
}
```

#### 5.2.4 版本单调递增

```kotlin
// 只允许升级到更高版本，防止降级攻击
fun isVersionValid(newVersion: String, currentVersion: String): Boolean {
    return compareVersion(newVersion, currentVersion) > 0
}
```

### 5.3 安全检查清单

```
更新前检查：
☑ HTTPS 连接验证
☑ 服务器证书验证
☑ 版本号合法性检查
☑ 灰度规则验证

下载后检查：
☑ 文件大小验证
☑ MD5 完整性校验
☑ RSA 签名验证
☑ Bundle 格式验证

安装前检查：
☑ 存储空间检查
☑ 备份当前版本
☑ 权限检查

安装后检查：
☑ 30秒超时检测
☑ 初始化状态验证
☑ 自动回滚机制
```

---

## 6. 回滚机制

### 6.1 回滚触发条件

```
自动回滚触发条件：
1. 初始化超时（30秒未调用 notifyScreenInitialized）
2. Bundle 加载失败
3. 运行时崩溃（连续3次）
4. 用户手动触发回滚
```

### 6.2 回滚流程

```
┌─────────────────────────────────────┐
│          回滚流程                    │
└─────────────────────────────────────┘

1. 检测到需要回滚
   ↓
2. 停止当前 ReactContext
   ↓
3. 从 backup 目录恢复上一版本
   ↓
4. 更新版本信息
   ↓
5. 重启应用
   ↓
6. 加载备份版本
   ↓
7. 上报回滚事件
```

### 6.3 回滚实现

```kotlin
fun rollbackToPreviousVersion() {
    try {
        Log.w(TAG, "开始回滚到上一版本")
        
        // 1. 获取备份版本信息
        val backupVersion = getBackupVersion()
        if (backupVersion == null) {
            Log.e(TAG, "没有可用的备份版本")
            return
        }
        
        // 2. 删除当前版本
        val currentDir = File(bundlesDir, "current")
        currentDir.deleteRecursively()
        
        // 3. 从备份恢复
        val backupDir = File(bundlesDir, "backup")
        backupDir.copyRecursively(currentDir)
        
        // 4. 更新版本信息
        updateCurrentVersion(backupVersion)
        
        // 5. 上报回滚事件
        reportRollback(backupVersion)
        
        Log.i(TAG, "回滚完成，版本：${backupVersion}")
    } catch (e: Exception) {
        Log.e(TAG, "回滚失败", e)
    }
}
```

---

## 7. 双屏更新支持

### 7.1 双屏更新流程

```
主副屏使用同一个 JS Bundle
更新时复用现有的 restartApplication() 机制

更新流程：
1. 下载新 Bundle
   ↓
2. 校验并安装
   ↓
3. 调用 MultiDisplayManager.restartApplication()
   ↓
4. 销毁副屏
   ↓
5. 重启主屏（加载新 Bundle）
   ↓
6. 主屏初始化完成
   ↓
7. 自动检测并启动副屏（加载新 Bundle）
```

### 7.2 关键代码

```kotlin
// 热更新完成后重启应用
fun applyUpdate() {
    val multiDisplayManager = MainActivity.instance?.getMultiDisplayManager()
    
    multiDisplayManager?.restartApplication {
        // 主屏重启回调
        // 跳转到 LoadingActivity
        val intent = Intent(context, LoadingActivity::class.java)
        context.startActivity(intent)
    }
}
```

---

## 总结

本章介绍了热更新的核心原理和机制：

1. **基础原理**：React Native 动态加载 JS Bundle
2. **工作流程**：从检查更新到应用更新的完整流程
3. **版本管理**：双版本号策略，保留10个历史版本
4. **更新策略**：强制、自动、提示三级策略
5. **安全机制**：HTTPS + RSA签名 + MD5校验
6. **回滚机制**：30秒超时自动回滚
7. **双屏支持**：复用现有重启机制

下一章将介绍系统架构设计。

