# 更新包管理

## 目录

1. [更新包打包流程](#1-更新包打包流程)
2. [版本号管理](#2-版本号管理)
3. [更新包存储](#3-更新包存储)
4. [更新包传输](#4-更新包传输)
5. [灰度发布策略](#5-灰度发布策略)

---

## 1. 更新包打包流程

### 1.1 打包流程图

```
┌─────────────────────────────────────────────────────────────┐
│                    更新包打包流程                            │
└─────────────────────────────────────────────────────────────┘

开发完成
   ↓
代码提交到 Git
   ↓
触发 CI/CD 流程
   ↓
┌─────────────────────────────────────────────────────────────┐
│ 1. 构建 JS Bundle                                           │
│    - 执行 Metro 打包                                        │
│    - 生成 index.android.bundle                              │
│    - 复制 assets 资源文件                                   │
└─────────────────────────────────────────────────────────────┘
   ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. 生成版本信息                                             │
│    - 读取 package.json 版本号                               │
│    - 生成 version.json                                      │
│    - 记录构建时间和描述                                     │
└─────────────────────────────────────────────────────────────┘
   ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. 计算文件签名                                             │
│    - 计算 Bundle 的 MD5                                     │
│    - 使用私钥生成 RSA 签名                                  │
│    - 写入 version.json                                      │
└─────────────────────────────────────────────────────────────┘
   ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. 打包压缩                                                 │
│    - 将 Bundle 和 assets 打包为 zip                         │
│    - 命名格式：bundle-{version}.zip                         │
└─────────────────────────────────────────────────────────────┘
   ↓
┌─────────────────────────────────────────────────────────────┐
│ 5. 上传到服务器                                             │
│    - 上传 zip 文件到文件服务器                              │
│    - 写入数据库版本记录                                     │
│    - 生成下载 URL                                           │
└─────────────────────────────────────────────────────────────┘
   ↓
┌─────────────────────────────────────────────────────────────┐
│ 6. 配置灰度规则（可选）                                     │
│    - 设置灰度设备/门店                                      │
│    - 设置灰度百分比                                         │
└─────────────────────────────────────────────────────────────┘
   ↓
┌─────────────────────────────────────────────────────────────┐
│ 7. 推送更新通知                                             │
│    - 通过 WebSocket 推送到目标设备                          │
│    - 记录推送日志                                           │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 打包脚本实现

#### 1.2.1 主打包脚本

```bash
#!/bin/bash
# scripts/build-bundle.sh

set -e

# 配置
BUNDLE_VERSION=$1
NATIVE_VERSION=$2
DESCRIPTION=$3
OUTPUT_DIR="./dist/bundles/${BUNDLE_VERSION}"
PRIVATE_KEY_PATH="./keys/private.pem"

echo "========================================="
echo "开始打包 Bundle"
echo "Bundle 版本: ${BUNDLE_VERSION}"
echo "原生版本: ${NATIVE_VERSION}"
echo "========================================="

# 1. 清理输出目录
rm -rf ${OUTPUT_DIR}
mkdir -p ${OUTPUT_DIR}

# 2. 构建 JS Bundle
echo "步骤 1/6: 构建 JS Bundle..."
npx react-native bundle \
  --platform android \
  --dev false \
  --entry-file index.js \
  --bundle-output ${OUTPUT_DIR}/index.android.bundle \
  --assets-dest ${OUTPUT_DIR}/assets

# 3. 生成版本信息
echo "步骤 2/6: 生成版本信息..."
cat > ${OUTPUT_DIR}/version.json << EOF
{
  "bundleVersion": "${BUNDLE_VERSION}",
  "nativeVersion": "${NATIVE_VERSION}",
  "buildTime": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
  "description": "${DESCRIPTION}"
}
EOF

# 4. 计算 MD5
echo "步骤 3/6: 计算 MD5..."
MD5=$(md5sum ${OUTPUT_DIR}/index.android.bundle | awk '{print $1}')
echo "MD5: ${MD5}"

# 5. 生成 RSA 签名
echo "步骤 4/6: 生成 RSA 签名..."
SIGNATURE=$(openssl dgst -sha256 -sign ${PRIVATE_KEY_PATH} \
  ${OUTPUT_DIR}/index.android.bundle | base64 -w 0)

# 6. 更新版本信息
echo "步骤 5/6: 更新版本信息..."
jq --arg md5 "$MD5" --arg sig "$SIGNATURE" \
  '.md5 = $md5 | .signature = $sig' \
  ${OUTPUT_DIR}/version.json > ${OUTPUT_DIR}/version.tmp.json
mv ${OUTPUT_DIR}/version.tmp.json ${OUTPUT_DIR}/version.json

# 7. 打包压缩
echo "步骤 6/6: 打包压缩..."
cd ${OUTPUT_DIR}
zip -r ../bundle-${BUNDLE_VERSION}.zip ./*
cd -

echo "========================================="
echo "打包完成！"
echo "输出文件: ./dist/bundles/bundle-${BUNDLE_VERSION}.zip"
echo "========================================="
```

#### 1.2.2 上传脚本

```bash
#!/bin/bash
# scripts/upload-bundle.sh

set -e

BUNDLE_VERSION=$1
BUNDLE_FILE="./dist/bundles/bundle-${BUNDLE_VERSION}.zip"
SERVER_URL="https://your-server.com"
API_TOKEN="your-api-token"

echo "上传 Bundle 到服务器..."

# 1. 上传文件
curl -X POST \
  -H "Authorization: Bearer ${API_TOKEN}" \
  -F "file=@${BUNDLE_FILE}" \
  -F "version=${BUNDLE_VERSION}" \
  ${SERVER_URL}/api/bundles/upload

echo "上传完成！"
```

### 1.3 CI/CD 集成

#### GitHub Actions 示例

```yaml
# .github/workflows/build-bundle.yml
name: Build and Deploy Bundle

on:
  push:
    tags:
      - 'bundle-v*'

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: yarn install

      - name: Extract version from tag
        id: version
        run: |
          TAG=${GITHUB_REF#refs/tags/bundle-v}
          echo "bundle_version=$TAG" >> $GITHUB_OUTPUT

      - name: Build Bundle
        run: |
          chmod +x ./scripts/build-bundle.sh
          ./scripts/build-bundle.sh \
            ${{ steps.version.outputs.bundle_version }} \
            "1.0.0" \
            "Auto build from CI"

      - name: Upload Bundle
        env:
          API_TOKEN: ${{ secrets.API_TOKEN }}
        run: |
          chmod +x ./scripts/upload-bundle.sh
          ./scripts/upload-bundle.sh \
            ${{ steps.version.outputs.bundle_version }}
```

---

## 2. 版本号管理

### 2.1 版本号规范

```
Bundle 版本号格式：主版本.次版本.修订版本.构建号
示例：1.2.3.456

主版本 (Major)：重大架构变更，不兼容旧版本
次版本 (Minor)：新功能添加，向后兼容
修订版本 (Patch)：Bug 修复，向后兼容
构建号 (Build)：每次构建自动递增
```

### 2.2 版本号生成策略

```typescript
// scripts/generate-version.ts

interface VersionInfo {
  major: number;
  minor: number;
  patch: number;
  build: number;
}

function generateVersion(
  currentVersion: string,
  changeType: 'major' | 'minor' | 'patch'
): string {
  const [major, minor, patch, build] = currentVersion
    .split('.')
    .map(Number);

  let newVersion: VersionInfo;

  switch (changeType) {
    case 'major':
      newVersion = {
        major: major + 1,
        minor: 0,
        patch: 0,
        build: 1
      };
      break;

    case 'minor':
      newVersion = {
        major,
        minor: minor + 1,
        patch: 0,
        build: 1
      };
      break;

    case 'patch':
      newVersion = {
        major,
        minor,
        patch: patch + 1,
        build: 1
      };
      break;
  }

  return `${newVersion.major}.${newVersion.minor}.${newVersion.patch}.${newVersion.build}`;
}

// 自动递增构建号
function incrementBuild(currentVersion: string): string {
  const parts = currentVersion.split('.');
  parts[3] = String(Number(parts[3]) + 1);
  return parts.join('.');
}
```

### 2.3 版本兼容性检查

```kotlin
// 客户端版本兼容性检查
data class Version(
    val major: Int,
    val minor: Int,
    val patch: Int,
    val build: Int
) {
    companion object {
        fun parse(versionStr: String): Version {
            val parts = versionStr.split(".")
            return Version(
                major = parts[0].toInt(),
                minor = parts[1].toInt(),
                patch = parts[2].toInt(),
                build = parts.getOrNull(3)?.toInt() ?: 0
            )
        }
    }

    fun isCompatibleWith(nativeVersion: String): Boolean {
        val native = parse(nativeVersion)
        // Bundle 的主版本和次版本必须与原生版本一致
        return this.major == native.major && this.minor == native.minor
    }

    fun isNewerThan(other: Version): Boolean {
        return when {
            this.major != other.major -> this.major > other.major
            this.minor != other.minor -> this.minor > other.minor
            this.patch != other.patch -> this.patch > other.patch
            else -> this.build > other.build
        }
    }
}
```


---

## 3. 更新包存储

### 3.1 服务端存储结构

```
/var/www/hot-update/
├── bundles/                          # Bundle 文件存储
│   ├── 1.0.0.450/
│   │   ├── index.android.bundle
│   │   ├── assets/
│   │   │   ├── fonts/
│   │   │   └── images/
│   │   └── version.json
│   ├── 1.0.0.451/
│   └── ...
│
├── packages/                         # 压缩包存储
│   ├── bundle-1.0.0.450.zip
│   ├── bundle-1.0.0.451.zip
│   └── ...
│
└── metadata/                         # 元数据
    ├── versions.json                 # 版本列表
    └── checksums.json                # 校验和列表
```

### 3.2 存储管理策略

#### 3.2.1 版本保留策略

```typescript
// 服务端版本清理策略
interface RetentionPolicy {
  maxVersions: number;        // 最多保留版本数
  minRetentionDays: number;   // 最少保留天数
  keepActiveVersions: boolean; // 保留活跃版本
}

const DEFAULT_POLICY: RetentionPolicy = {
  maxVersions: 50,            // 保留最近 50 个版本
  minRetentionDays: 90,       // 至少保留 90 天
  keepActiveVersions: true    // 保留所有活跃版本
};

async function cleanupOldVersions(policy: RetentionPolicy) {
  const versions = await getVersionList();
  const now = Date.now();
  
  // 1. 过滤出可以删除的版本
  const deletableVersions = versions.filter(v => {
    // 保留活跃版本
    if (policy.keepActiveVersions && v.isActive) {
      return false;
    }
    
    // 保留最近的版本
    const age = now - new Date(v.createdAt).getTime();
    const days = age / (1000 * 60 * 60 * 24);
    if (days < policy.minRetentionDays) {
      return false;
    }
    
    return true;
  });
  
  // 2. 按时间排序，保留最新的 N 个版本
  deletableVersions.sort((a, b) => 
    new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
  );
  
  const toDelete = deletableVersions.slice(policy.maxVersions);
  
  // 3. 删除旧版本
  for (const version of toDelete) {
    await deleteVersion(version.bundleVersion);
  }
}
```

### 3.3 客户端存储管理

#### 3.3.1 存储空间检查

```kotlin
fun checkStorageSpace(requiredBytes: Long): Boolean {
    val bundlesDir = File(context.filesDir, "bundles")
    val statFs = StatFs(bundlesDir.absolutePath)
    
    val availableBytes = statFs.availableBytes
    val requiredWithBuffer = requiredBytes * 1.2 // 预留 20% 缓冲
    
    return availableBytes >= requiredWithBuffer
}
```

#### 3.3.2 历史版本清理

```kotlin
fun cleanupHistoryVersions() {
    val historyDir = File(bundlesDir, "history")
    val versions = historyDir.listFiles()?.sortedByDescending { 
        it.lastModified() 
    } ?: return
    
    // 保留最近 10 个版本
    val toDelete = versions.drop(10)
    toDelete.forEach { it.deleteRecursively() }
}
```

---

## 4. 更新包传输

### 4.1 下载流程

```kotlin
class DownloadManager(private val context: Context) {
    
    private val client = OkHttpClient.Builder()
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(60, TimeUnit.SECONDS)
        .build()
    
    suspend fun downloadBundle(
        url: String,
        onProgress: (progress: Int) -> Unit
    ): Result<File> = withContext(Dispatchers.IO) {
        try {
            val request = Request.Builder()
                .url(url)
                .build()
            
            val response = client.newCall(request).execute()
            if (!response.isSuccessful) {
                return@withContext Result.failure(
                    Exception("下载失败: ${response.code}")
                )
            }
            
            val body = response.body ?: return@withContext Result.failure(
                Exception("响应体为空")
            )
            
            val totalBytes = body.contentLength()
            val downloadFile = File(context.cacheDir, "bundle_download.zip")
            
            body.byteStream().use { input ->
                downloadFile.outputStream().use { output ->
                    val buffer = ByteArray(8192)
                    var bytesRead: Int
                    var totalBytesRead = 0L
                    
                    while (input.read(buffer).also { bytesRead = it } != -1) {
                        output.write(buffer, 0, bytesRead)
                        totalBytesRead += bytesRead
                        
                        // 更新进度
                        val progress = (totalBytesRead * 100 / totalBytes).toInt()
                        onProgress(progress)
                    }
                }
            }
            
            Result.success(downloadFile)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### 4.2 传输优化

#### 4.2.1 并发下载控制

```kotlin
// 限制同时下载的任务数
private val downloadSemaphore = Semaphore(1)

suspend fun downloadWithLimit(url: String): Result<File> {
    downloadSemaphore.acquire()
    try {
        return downloadBundle(url) { progress ->
            // 更新进度
        }
    } finally {
        downloadSemaphore.release()
    }
}
```

#### 4.2.2 网络状态检测

```kotlin
fun isNetworkAvailable(): Boolean {
    val connectivityManager = context.getSystemService(
        Context.CONNECTIVITY_SERVICE
    ) as ConnectivityManager
    
    val network = connectivityManager.activeNetwork ?: return false
    val capabilities = connectivityManager.getNetworkCapabilities(network)
    
    return capabilities?.hasCapability(
        NetworkCapabilities.NET_CAPABILITY_INTERNET
    ) == true
}

fun isWifiConnected(): Boolean {
    val connectivityManager = context.getSystemService(
        Context.CONNECTIVITY_SERVICE
    ) as ConnectivityManager
    
    val network = connectivityManager.activeNetwork ?: return false
    val capabilities = connectivityManager.getNetworkCapabilities(network)
    
    return capabilities?.hasTransport(
        NetworkCapabilities.TRANSPORT_WIFI
    ) == true
}
```

